# 探索 → 遇敌 → 接战 → 战斗 编程化动画系统

## 📖 系统概述

本系统实现了从探索阶段到正式战斗的完整动态过渡流程，采用纯编程方式而非 Timeline 静态方案，确保最大的灵活性和适应性。

### 🎯 核心特点

- **动态适应**：自动适配不同队伍大小、职业组合、场景布局
- **编程化控制**：完全通过代码控制，支持复杂的条件逻辑和动态调整
- **平滑过渡**：使用 DOTween 创建自然的移动动画和缓动效果
- **状态管理**：完整的战斗状态机，涵盖从探索到战斗的所有阶段
- **无缝集成**：与现有战斗系统完美兼容，不破坏原有功能

## 🎬 流程阶段

### 1. 探索阶段 (PreBattle)

- 玩家队伍在探索区域自由移动
- 系统监听遇敌事件触发
- 敌人队伍在远处待命或动态生成

### 2. 遇敌触发 (Encounter Trigger)

- 通过脚本调用或事件系统触发
- 自动识别参与战斗的双方队伍
- 计算并准备最优战斗位置

### 3. 接战动画 (Approaching)

- 玩家队伍从探索区移动到战斗位置
- 角色依次启动移动，创造自然的群体效果
- 敌人队伍已就位，面朝玩家等待接战

### 4. 阵型就位 (Formation)

- 所有角色到达预定战斗位置
- 双方自动调整朝向面对敌人
- 短暂准备阶段

### 5. 正式战斗 (Combat)

- 无缝过渡到标准 DND5E 战斗流程
- 掷先攻、回合制战斗等一切正常运行

## 🛠️ 核心 API

### CombatManager 主要方法

```csharp
/// <summary>
/// 开始完整的探索到战斗流程（主入口点）
/// </summary>
/// <param name="playerTeam">玩家队伍</param>
/// <param name="enemyTeam">敌人队伍</param>
/// <param name="explorePositions">可选：自定义探索区起始位置</param>
public void StartExplorationToCombatSequence(
    List<CharacterStats> playerTeam,
    List<CharacterStats> enemyTeam,
    Vector3[] explorePositions = null
)

/// <summary>
/// 开始接战动画序列
/// </summary>
public void StartApproachSequence()
```

### BattleFormationManager 扩展方法

```csharp
/// <summary>
/// 获取玩家spawn点数组
/// </summary>
public Transform[] GetPlayerSpawnPoints()

/// <summary>
/// 获取敌人spawn点数组
/// </summary>
public Transform[] GetEnemySpawnPoints()

/// <summary>
/// 排列现有队伍到战斗位置（现已公开）
/// </summary>
public void ArrangeExistingTeam(List<CharacterStats> team, BattleSide side)
```

## 🔧 配置参数

### CombatManager 接战动画配置

```csharp
[Header("接战动画配置")]
public float approachSpeed = 3f;              // 移动速度
public Ease approachEaseType = Ease.OutQuart; // 缓动类型
public float characterMoveDelay = 0.2f;       // 角色间移动延迟
```

### 战斗状态枚举扩展

```csharp
public enum CombatState {
    Inactive,           // 未激活
    PreBattle,          // 探索阶段 - 战斗前准备
    Approaching,        // 接战阶段 - 玩家队伍向战斗位置移动
    Formation,          // 阵型就位 - 双方到达战斗位置
    RollingInitiative,  // 掷先攻
    TurnStart,          // 回合开始
    ActionSelection,    // 行动选择
    ExecutingAction,    // 执行行动
    TurnEnd,            // 回合结束
    CombatEnd           // 战斗结束
}
```

## 📝 使用示例

### 基础用法

```csharp
// 获取玩家和敌人队伍
List<CharacterStats> playerTeam = GetPlayerParty();
List<CharacterStats> enemyTeam = GenerateEnemyEncounter();

// 启动完整流程（使用默认探索区位置）
CombatManager.Instance.StartExplorationToCombatSequence(playerTeam, enemyTeam);
```

### 高级用法

```csharp
// 自定义探索区起始位置
Vector3[] customExplorePositions = {
    new Vector3(-10, 2, 0),   // 队长位置
    new Vector3(-10, 0, 0),   // 战士位置
    new Vector3(-10, -2, 0),  // 法师位置
    new Vector3(-12, 1, 0)    // 盗贼位置
};

// 启动带自定义位置的流程
CombatManager.Instance.StartExplorationToCombatSequence(
    playerTeam,
    enemyTeam,
    customExplorePositions
);
```

### 事件监听

```csharp
// 监听战斗状态变化
void OnEnable() {
    CombatManager.Instance.OnCombatStart += HandleCombatStart;
    CombatManager.Instance.OnCombatEnd += HandleCombatEnd;
}

void HandleCombatStart() {
    Debug.Log("战斗开始，可以更新UI或触发其他系统");
}
```

## 📋 队伍配置说明

### 🔧 配置统一性问题

您提出的问题非常准确！当前系统确实存在重复配置的问题：

**重复配置的地方：**

1. **BattleFormationManager.cs** - 包含预制体数组（已废弃）

   ```csharp
   public GameObject[] playerCharacterPrefabs = new GameObject[6];
   public GameObject[] enemyCharacterPrefabs = new GameObject[6];
   ```

2. **ExplorationToCombatDemo.cs** - 包含角色实例列表（推荐使用）
   ```csharp
   public List<CharacterStats> playerTeam = new List<CharacterStats>();
   public List<CharacterStats> enemyTeam = new List<CharacterStats>();
   ```

### ✅ 推荐的统一配置方案

**唯一配置入口：ExplorationToCombatDemo**

- 配置内容：角色实例（CharacterStats），不是预制体
- 配置方式：直接拖拽场景中已存在的角色到列表中
- 使用场景：实际游戏中的接战动画和战斗

**BattleFormationManager 的职责：**

- 仅负责生成 spawn 点和管理阵型
- 不再负责角色生成（避免重复）
- 提供位置计算和排列服务

### 🚫 已废弃的配置

BattleFormationManager 中的预制体数组已废弃，原因：

1. **功能重复**：与 ExplorationToCombatDemo 的队伍配置重复
2. **设计冲突**：一个系统生成新角色，另一个系统使用现有角色
3. **维护困难**：两套配置需要同步维护，容易出错

### 📝 正确的使用流程

```csharp
// 1. 在场景中放置角色GameObject
// 2. 配置ExplorationToCombatDemo脚本
ExplorationToCombatDemo demo = GetComponent<ExplorationToCombatDemo>();
demo.playerTeam.Add(heroCharacter);   // 添加场景中的角色实例
demo.enemyTeam.Add(enemyCharacter);   // 添加场景中的敌人实例

// 3. 使用API启动流程
CombatManager.Instance.StartExplorationToCombatSequence(demo.playerTeam, demo.enemyTeam);
```

### 🔄 配置迁移建议

**从 BattleFormationManager 预制体配置迁移到统一配置：**

1. **停止使用**：不再在 BattleFormationManager 中配置预制体
2. **转移配置**：将角色配置全部移至 ExplorationToCombatDemo
3. **使用实例**：配置角色实例而非预制体，支持更灵活的角色定制

## 🎮 演示脚本使用（统一配置入口）

### ExplorationToCombatDemo - 唯一推荐的配置方式

1. **设置演示脚本**

   - 将`ExplorationToCombatDemo.cs`添加到场景中的任意 GameObject
   - ⚠️ **重要**：直接拖拽场景中的角色实例（CharacterStats）到队伍列表中
   - ❌ **不要**：使用 BattleFormationManager 中的预制体配置（已废弃）

2. **正确的队伍配置**

   ```csharp
   // 推荐方式：使用角色实例
   [Header("玩家队伍配置 - 拖拽场景中的角色")]
   public List<CharacterStats> playerTeam;

   [Header("敌人队伍配置 - 拖拽场景中的角色")]
   public List<CharacterStats> enemyTeam;
   ```

3. **运行演示**

   - 运行游戏
   - 按下空格键（或配置的触发键）开始演示
   - 观察完整的接战动画流程

4. **自定义配置**
   - 勾选`Use Custom Explore Positions`使用自定义探索区位置
   - 通过`Custom Explore Positions`数组设置起始点
   - 调整移动速度和缓动效果

## 🔄 与现有系统兼容性

### 保持兼容的设计原则

1. **非破坏性扩展**：所有新功能都是 additive 的，不修改现有 API
2. **可选使用**：可以继续使用原有的`StartCombat()`方法，新系统完全可选
3. **状态机扩展**：战斗状态机向前兼容，添加了新状态但不影响现有状态
4. **事件系统保持**：所有现有的战斗事件继续正常工作

### 迁移指南

**从直接战斗切换到接战动画：**

```csharp
// 旧方式：直接开始战斗
List<CharacterStats> allCombatants = new List<CharacterStats>();
allCombatants.AddRange(playerTeam);
allCombatants.AddRange(enemyTeam);
CombatManager.Instance.StartCombat(allCombatants);

// 新方式：包含接战动画的完整流程
CombatManager.Instance.StartExplorationToCombatSequence(playerTeam, enemyTeam);
```

## ⚠️ 注意事项和最佳实践

### 标签配置要求

确保角色 GameObject 有正确的标签：

- 玩家角色：`"Player"` 或 `"Ally"`
- 敌人角色：`"Enemy"`

### 性能优化建议

1. **队伍大小限制**：建议单方队伍不超过 6 人，保持流畅的动画效果
2. **移动距离控制**：探索区与战斗区距离建议在 5-15 个单位之间
3. **动画延迟调整**：根据队伍大小调整`characterMoveDelay`参数

### 调试和测试

1. **启用详细日志**：系统包含丰富的 Debug.Log 信息
2. **使用演示脚本**：通过`ExplorationToCombatDemo`快速测试不同配置
3. **状态监控**：观察`CombatManager.currentState`来跟踪流程进度

## 🔮 扩展可能性

### 未来增强方向

1. **动画事件系统**：在接战过程中触发特效、音效、对话等
2. **地形适应**：根据地形自动调整移动路径和最终位置
3. **职业特化动画**：不同职业使用不同的接战移动风格
4. **AI 决策集成**：敌人 AI 可以根据玩家接战行为做出反应

### 自定义扩展点

```csharp
// 可以重写的虚方法（未来版本）
protected virtual void OnApproachStarted() { }
protected virtual void OnCharacterReachedPosition(CharacterStats character) { }
protected virtual void OnFormationCompleted() { }
```

## 📊 技术架构总结

- **主控制器**：`CombatManager` - 统一管理整个流程
- **位置管理**：`BattleFormationManager` - 处理 spawn 点和阵型
- **动画引擎**：DOTween - 提供平滑的移动和缓动效果
- **状态机**：扩展的`CombatState`枚举 - 精确控制每个阶段
- **事件系统**：保持现有的事件委托机制 - 确保系统间解耦

这个系统完全采用编程方式实现，避免了 Timeline 的静态限制，为横版 2D DND5E 战斗系统提供了动态、灵活、易于扩展的接战动画解决方案。

## ❓ 常见问题解答 (FAQ)

### Q: 队伍配置文件意义何在？是否需要填入玩家和敌人 prefab？

**A: 配置已统一，避免重复配置**

**❌ 不推荐**：BattleFormationManager 中的预制体配置（已废弃）

- 原设计用于从预制体生成新角色
- 与新的接战动画系统产生冲突
- 造成重复配置和维护困难

**✅ 推荐**：ExplorationToCombatDemo 中的角色实例配置

- 直接使用场景中已存在的角色
- 支持更灵活的角色定制和状态管理
- 与接战动画系统完美配合

### Q: 和阵型配置是否统一？是否重复配置了 prefab？

**A: 确实存在重复，已进行职责分离**

**系统职责分离：**

- **BattleFormationManager**：专注 spawn 点生成和阵型管理
- **ExplorationToCombatDemo**：负责队伍配置和流程管理
- **CombatManager**：负责接战动画和战斗流程

**避免重复配置的方法：**

1. 只在 ExplorationToCombatDemo 中配置队伍
2. BattleFormationManager 自动提供 spawn 点
3. 使用角色实例而非预制体

### Q: 如何正确配置队伍？

**A: 统一使用 ExplorationToCombatDemo**

```csharp
// 步骤1：在场景中放置角色GameObject
// 步骤2：将角色拖拽到ExplorationToCombatDemo的队伍列表中
// 步骤3：运行游戏，按空格键测试

// 代码调用方式：
CombatManager.Instance.StartExplorationToCombatSequence(playerTeam, enemyTeam);
```

### Q: 旧的预制体配置还能用吗？

**A: 不推荐使用，建议迁移**

旧的预制体配置系统有以下问题：

- 功能重复，维护困难
- 不支持角色状态定制
- 与接战动画流程不兼容

**迁移步骤：**

1. 从预制体生成角色实例到场景中
2. 配置角色的属性、装备、状态等
3. 将角色实例添加到 ExplorationToCombatDemo
4. 停止使用 BattleFormationManager 的预制体配置
